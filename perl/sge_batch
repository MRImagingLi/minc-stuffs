
#!/usr/bin/perl -w

# a simple batch interface to SGE's qsub

use strict;
use Getopt::Tabular;

my $outputFile = undef;
my $errorFile = undef;
my $jobName = undef;
my $joinStreams = 0;
my $printJob = 0;
my $sgeOpts = "";
my $sgePriority = undef;
my $sgeQueue = "all.q";
my $sgeSMP = undef;

my @command;
my @opt_args;
my @argTbl = 
    (["-o", "string", 1, \$outputFile,
      "File for stdout"],
     ["-e", "string", 1, \$errorFile,
      "File for stderr"],
     ["-k", "boolean", undef, \$joinStreams,
      "Combine stderr and stdout"],
     ["-J", "string", 1, \$jobName,
      "Symbolic job name."],
     ["-n", "boolean", undef, \$printJob,
      "Just print the job script, don't execute"],
     ["-l", "string", 1, \$sgeOpts,
      "Extra opts to pass to qsub"],
     ["-q", "string", 1, \$sgeQueue,
      "Queue to run the job on"],
     ["-p", "integer", 1, \$sgePriority,
      "Priority with which to run job"],
     ["-m", "integer", 1, \$sgeSMP,
      "Number of processors used by job"]
     );

# N.B. Argument stuff stolen mischievously from Andrew!
# first rip out only the args that ParseArgv should get
my $state = 0;
foreach (@ARGV){
   
   if($state == 2){
      push(@command, $_);
      next;
      }
   
   if($state == 1){
      push(@opt_args, $_);
      $state = 0;
      next;
      }
   
   if(m/^\-(k|n|help)/){
      push(@opt_args, $_);
      }
   elsif(m/^\-(J|o|e|l|p|m|q)/){
      push(@opt_args, $_);
      $state = 1;
      }
   else{
      push(@command, $_);
      $state = 2;
      }
   }

#print "Args: $argTbl[0][0,3]\n";

GetOptions(\@argTbl, \@opt_args) or die "\n";

die "Must specify command!\n" if ($#command == -1);

# ensure a legal job name
if ($jobName) {
    $jobName =~ s/;/_/g;
    $jobName =~ s/,/_/g;
    $jobName =~ s/\s/_/g;
    $jobName = "N$jobName" if ($jobName !~ /^[a-zA-Z]/); 
}

# output file is used for log if specified, else the output is placed
# into the directory specified by the environment variable
# SGE_BATCH_LOGDIR, else the default from qsub is used.
if ($outputFile) { 
    # do nothing
}
elsif (exists($ENV{SGE_BATCH_LOGDIR})) {
    $outputFile = $ENV{SGE_BATCH_LOGDIR};
    $errorFile = $outputFile;
}

# if environment variable SGE_BATCH_JOINSTREAM exists, join streams.
if (exists($ENV{SGE_BATCH_JOINSTREAM})) {
    $joinStreams=1;
}

# only use the options environment variable when no explicit options have been requested
if (exists($ENV{SGE_BATCH_OPTIONS}) and ($sgeOpts eq "")) {
  $sgeOpts = $ENV{SGE_BATCH_OPTIONS};
}

my $jobScript = <<END;
#!/bin/sh
# generated by JPL's sge_batch script
END

# specify all of the SGE options
$jobScript .= "\#\$ -o $outputFile\n" if $outputFile;
$jobScript .= "\#\$ -j y\n" if $joinStreams;
$jobScript .= "\#\$ -e $errorFile\n" if (! $joinStreams and $errorFile);
$jobScript .= "\#\$ -N $jobName\n" if $jobName;
$jobScript .= "\#\$ -q $sgeQueue\n" if $sgeQueue;
$jobScript .= "\n";

# switch to current working directory
$jobScript .= "cd \$SGE_O_WORKDIR\n\n";

# add the environment
foreach my $env ( keys %ENV ) {
  # hack since the following scheme isn't smart enough to correctly quote functions
  if (!($env =~ "^BASH_FUNC_")) {
	$jobScript .= "export ${env}=\"$ENV{$env}\"\n";
  }
}
$jobScript .= "\n";


# add the arguments themselves
$jobScript .= "@command \n";

$sgeOpts = "-l $sgeOpts" if $sgeOpts;
$sgeOpts .= " -p $sgePriority" if $sgePriority;
$sgeOpts .= " -pe smp $sgeSMP" if $sgeSMP;

if ($printJob) {
    print $jobScript;
    print "qsub -S /bin/bash $sgeOpts\n";
}
else {
    open (JOBSCRIPT, '>>.jobscript');
    print JOBSCRIPT $jobScript;
    close(JOBSCRIPT);
    open PIPE, "|qsub -S /bin/bash $sgeOpts"
        or die "ERROR: could not open pipe to qsub: $!\n";
    print PIPE $jobScript;
    if (! close PIPE ) {
        die "ERROR closing pipe to qsub: $!\n";
    }
}
